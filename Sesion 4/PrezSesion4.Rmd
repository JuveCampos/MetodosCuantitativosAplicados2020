---
title: "<br><br>Laboratorio 4"
subtitle: "Respuestas<br>Segundo Exámen Parcial"
author: "<br><br><br>Métodos Cuantitativos Aplicados, 2020<br>Juvenal Campos"
institute: "CIDE-LNPP"
date: "`r Sys.Date()`"
output:
  xaringan::moon_reader:
    css: [cide, ninjutsu]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval = TRUE)
library(pacman)
p_load(infer, knitr, tidyverse)
```

## Ejercicio 1 (40 pts.) {-}

El siguiente código te permitirá cargar una muestra aleatoria con los resultados de la elección presidencial de **100** de las más de **156 mil casillas** que se instalaron en la elección presidencial de 2018.

```{r, warning=F, message=F}
computos <- 
  read_csv("http://segasi.com.mx/clases/cide/datos/muestra_c_pdte_2018.csv")
```

La base de datos incluye seis columnas: `entidad`, `distrito`, `clave casilla` (id único de cada casilla) y `vs_anaya`, `vs_meade` y `vs_amlo`. Las tres últimas variables contienen el porcentaje de votos obtenidos por el respectivo candidato.

**Elige una de las columnas `vs_anaya`, `vs_meade` y `vs_amlo` y haz lo siguiente:**

---

1) **Estima la media del porcentaje de votos** obtenidos por el candidato que seleccionaste (5 pts.).

**Para los tres candidatos:**

```{r, echo=T, eval=T}
computos %>% 
  summarise(media_muestral_anaya = mean(vs_anaya, na.rm = T),
            media_muestral_meade = mean(vs_meade, na.rm = T),
            media_muestral_amlo = mean(vs_amlo, na.rm = T))
```

---

2) **Calcula el error estándar de la _distribución muestral_** asociada al estimador que calculaste en el punto anterior (10 pts.).

**Para Anaya: **

```{r, echo=T, eval=T}
# Anaya
set.seed(1)
computos %>% 
  rep_sample_n(size = nrow(computos), replace = T, reps = 5000) %>% 
  summarise(media_muestral = mean(vs_anaya, na.rm = T)) %>%
  summarise(error_estandar = sd(media_muestral, na.rm = T))
  
```

* Aquí (y en los subsecuentes) lo que Segasi hace es calcular promedios muestrales con 5000 muestras con reemplazo de tamaño 100. 

---

2) **Calcula el error estándar de la _distribución muestral_** asociada al estimador que calculaste en el punto anterior (10 pts.).

**Para Meade: **

```{r, echo=T, eval=T}
# Meade
set.seed(1)
computos %>% 
  rep_sample_n(size = nrow(computos), replace = T, reps = 5000) %>% 
  summarise(media_muestral = mean(vs_meade, na.rm = T)) %>%
  summarise(error_estandar = sd(media_muestral, na.rm = T))
```

---

2) **Calcula el error estándar de la _distribución muestral_** asociada al estimador que calculaste en el punto anterior (10 pts.).

**Para AMLO: **

```{r, echo=T, eval=T}
# AMLO
set.seed(1)
computos %>% 
  rep_sample_n(size = nrow(computos), replace = T, reps = 5000) %>% 
  summarise(media_muestral = mean(vs_amlo, na.rm = T)) %>%
  summarise(error_estandar = sd(media_muestral, na.rm = T))
```

---

3) Construye un intervalo de confianza con un nivel de confianza de 95% (15 pts.)

* Recordemos que el *valor Z* de un 95% de confianza es igual a **1.96**. 

**Para Anaya: **

```{r, echo=T, eval=T}
# Anaya
set.seed(1)
computos %>% 
  rep_sample_n(size = nrow(computos), replace = T, reps = 1) %>% 
  summarise(media_muestral = mean(vs_anaya, na.rm = T), 
            EE = sd(vs_anaya, na.rm = T)/sqrt(nrow(computos))) %>% 
  summarise(limite_inf = media_muestral - 1.96*EE ,
            limite_sup = media_muestral + 1.96*EE, 
            media_muestral = media_muestral)

```

---

3) Construye un intervalo de confianza con un nivel de confianza de 95% (15 pts.)

**Para Meade: **

```{r, echo=T, eval=T}
# Meade
set.seed(1)
computos %>% 
  rep_sample_n(size = nrow(computos), replace = T, reps = 1) %>% 
  summarise(media_muestral = mean(vs_meade, na.rm = T), 
            EE = sd(vs_meade, na.rm = T)/sqrt(nrow(computos))) %>% 
  summarise(limite_inf = media_muestral - 1.96*EE ,
            limite_sup = media_muestral + 1.96*EE, 
            media_muestral = media_muestral)
```

---

3) Construye un intervalo de confianza con un nivel de confianza de 95% (15 pts.)

**Para AMLO: **

```{r, echo=T, eval=T}
# AMLO
set.seed(1)
computos %>% 
  rep_sample_n(size = nrow(computos), replace = T, reps = 1) %>% 
  summarise(media_muestral = mean(vs_amlo, na.rm = T), 
            EE = sd(vs_amlo, na.rm = T)/sqrt(nrow(computos))) %>% 
  summarise(limite_inf = media_muestral - 1.96*EE ,
            limite_sup = media_muestral + 1.96*EE, 
            media_muestral = media_muestral)
```

---

4) Supongamos que todo este análisis es para el equipo de campaña del candidato que elegiste (15 pts.). 

- **¿Crees que estarían satisfechos (en términos estadísticos) con los resultados que les entregas?**

- **¿Qué les sugerirías para mejorar tu próxima estimación?**

---

## Ejercicio 2 (20 pts.) {-}

Además de toda la magia que `ggplot2` ofrece para graficar, es un paquete que viene con varias bases de datos incluidas. Una de ellas es `midwest`, una base de datos con **28** variables sobre los **437** condados en el *Midwest* de Estados Unidos.

Para usar estos datos, solo debes escribir `midwest` en RStudio. 

1) Calcula el máximo de la variable `poptotal` usando los datos de *toda* la base (5 pts).

```{r, eval = T, echo = T}
max(midwest$poptotal)
```

---

2) Usando lo visto en clase, determina **computacionalmente** si el máximo es un estimador insesgado (15 pts).

```{r, eval = T, echo = T}
midwest %>% 
  rep_sample_n(size = 100, replace = F, reps = 1000) %>% 
  summarise(maximo_muestral = max(poptotal)) %>% 
  summarise(promedio_maximo_muestral = mean(maximo_muestral))
```

Si el valor máximo de la `poptotal` es de 5´105,067, y el valor esperado es de 2´142,780, podemos pensar que no es un estimador insesgado, ya que su valor esperado (su promedio) está muy lejos del valor poblacional. 

---

## Ejercicio 3 (40 pts.) {-}

1) Simula la distribución de probabilidad de una variable aleatoria con las siguientes especificaciones (5 pts.):

- Se distribuye como una Normal, con $\mu=7$ y $\sigma=2.5$;

- Debes usar 100 mil procesos aleatorios para generar los datos, para quedarte con un vector de las mismas dimensiones.

- Guarda las 100 mil observaciones en un vector llamado `valores`, que a su vez debes guardar en un `tibble`. Debes guardar el `tibble` en un objeto llamado `datos`.

- Usa `set.seed(89)` **antes** de simular los datos

```{r, eval = T, echo = T}
set.seed(89)
datos <- tibble(valores = rnorm(n = 1e5, 
                                mean = 7, 
                                sd = 2.5))
```

---

2) Toma **1,000** muestras aleatorias de tamaño **500** de `datos`. Después, haz lo siguiente (15 pts.):

- Para cada una de las muestras, calcula la media.

- Calcula de forma *computacional* el error estándar de la distribución muestral utilizando las *1,000* estimaciones que recien calculaste.

```{r, eval = T, echo = T}
datos %>% 
  rep_sample_n(size = 500, replace = F, reps = 1000) %>% 
# - Para cada una de las muestras, calcula la media.  
  summarise(media_muestral = mean(valores)) %>% 
# Calcula de forma *computacional* el EE de la distribución muestral
  summarise(error_estandar = sd(media_muestral))
```

---

3) Toma solo **una** muestra aleatoria de tamaño **500** de `datos`. Después, haz lo siguiente (20 pts.):

- Calcula la media muestral
- Calcula de forma *analítica* el error estándar de la distribución muestral asociada a tu estimador, usando el valor de la desviación estándar poblacional
- Calcula de forma *analítica* el error estándar de la distribución muestral, asumiendo que -como suele ocurrir en la realidad- **no conoces** el valor de la desviación estándar poblacional.

```{r, eval = T, echo = T}
datos %>% 
  rep_sample_n(size = 500, replace = F, reps = 1) %>% 
  summarise(media_muestral = mean(valores), 
            EEconDatosPoblacionales = 2.5/sqrt(500),   # Conociendo los parametros poblacionales
            EEAnalitico = sd(valores)/sqrt(500))    # Calculo analítico
```

---

## Ejercicio extra (40 pts.) {-}

Copia y ejecuta el siguiente código:

```{r, eval = T}
foo <- 
  tibble(valores = rnorm(n = 10000, mean = 14, sd = 3.5)) %>%
  rep_sample_n(size = 500, replace = F, reps = 10000) %>% 
  summarise(varianza_muestral = var(valores))
```

---

Después de hacerlo, deberías un `tibble` como este:

```{r, echo = T}
foo <- 
  tibble(valores = rnorm(n = 10000, mean = 14, sd = 3.5)) %>%
  rep_sample_n(size = 500, replace = F, reps = 10000) %>% 
  summarise(varianza_muestral = var(valores))

foo
```

---

Por favor, haz calcula y/o grafica todo lo que puedas a partir de la columna varianza muestral.

**¿Qué podemos calcular o graficar?**

* (1.) El valor de la varianza. 

```{r}
# Si la varianza es el cuadrado de la desviación estandar, y conocemos 
## el valor de la desv. est. poblacional (3.5), entonces 
varianza <- 3.5*3.5
varianza
```

La varianza poblacional es igual a **12.25**.

---

* (2.) Podemos graficar la distribución de la varianza muestral: 

```{r, out.height=300, fig.align='center'}
# Distribución de la varianza. 
foo %>% 
  ggplot(aes(x = varianza_muestral)) + 
  geom_density() + 
  geom_vline(xintercept = varianza, color = "red", 
             linetype = 2)
```

---

* (3.) Podemos sacar el error estándar de la distribución muestral de la varianza. 

```{r}
foo %>% 
  summarise(EEvarianza = sd(varianza_muestral))
```

---

* (4.) Podemos sacar el error muestral, para cada muestra, dado que conocemos los parámetros poblacionales.

```{r}
foo %>% 
  mutate(errorMuestral = varianza_muestral - varianza)
```

---

* (5.) Podemos graficar el error muestral

```{r, out.height=300, fig.align='center'}
foo %>% 
  mutate(errorMuestral = varianza_muestral - 3.5^2) %>% 
  ggplot(aes(errorMuestral)) + 
  geom_density() + 
  geom_vline(xintercept = 0, color = "blue", 
             linetype = 2) + 
  geom_vline(xintercept = -0.1392231, color = "red", 
             linetype = 2)
```

---

...y le sacamos el valor esperado, para ver si es igual a cero...

```{r}
foo %>% 
  mutate(errorMuestral = varianza_muestral - 3.5^2) %>% 
  summarise(valorEsperadoerrorMuestral = mean(errorMuestral))
```

No es igual a cero, por lo tanto la varianza es un estimador sesgado. 

--

**¿o no?**
