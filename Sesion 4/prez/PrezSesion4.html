<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>  Laboratorio 4</title>
    <meta charset="utf-8" />
    <meta name="author" content="   Métodos Cuantitativos Aplicados, 2020 Juvenal Campos" />
    <meta name="date" content="2020-03-31" />
    <link href="libs/remark-css-0.0.1/cide.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/ninjutsu.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# <br><br>Laboratorio 4
## Respuestas<br>Segundo Exámen Parcial
### <br><br><br>Métodos Cuantitativos Aplicados, 2020<br>Juvenal Campos
### CIDE-LNPP
### 2020-03-31

---




## Ejercicio 1 (40 pts.) {-}

El siguiente código te permitirá cargar una muestra aleatoria con los resultados de la elección presidencial de **100** de las más de **156 mil casillas** que se instalaron en la elección presidencial de 2018.


```r
computos &lt;- 
  read_csv("http://segasi.com.mx/clases/cide/datos/muestra_c_pdte_2018.csv")
```

La base de datos incluye seis columnas: `entidad`, `distrito`, `clave casilla` (id único de cada casilla) y `vs_anaya`, `vs_meade` y `vs_amlo`. Las tres últimas variables contienen el porcentaje de votos obtenidos por el respectivo candidato.

**Elige una de las columnas `vs_anaya`, `vs_meade` y `vs_amlo` y haz lo siguiente:**

---

1) **Estima la media del porcentaje de votos** obtenidos por el candidato que seleccionaste (5 pts.).

**Para los tres candidatos:**


```r
computos %&gt;% 
  summarise(media_muestral_anaya = mean(vs_anaya, na.rm = T),
            media_muestral_meade = mean(vs_meade, na.rm = T),
            media_muestral_amlo = mean(vs_amlo, na.rm = T))
```

```
## # A tibble: 1 x 3
##   media_muestral_anaya media_muestral_meade media_muestral_amlo
##                  &lt;dbl&gt;                &lt;dbl&gt;               &lt;dbl&gt;
## 1                 24.0                 17.8                49.0
```

---

2) **Calcula el error estándar de la _distribución muestral_** asociada al estimador que calculaste en el punto anterior (10 pts.).

**Para Anaya: **


```r
# Anaya
set.seed(1)
computos %&gt;% 
  rep_sample_n(size = nrow(computos), replace = T, reps = 5000) %&gt;% 
  summarise(media_muestral = mean(vs_anaya, na.rm = T)) %&gt;%
  summarise(error_estandar = sd(media_muestral, na.rm = T))
```

```
## # A tibble: 1 x 1
##   error_estandar
##            &lt;dbl&gt;
## 1           1.28
```

* Aquí (y en los subsecuentes) lo que Segasi hace es calcular promedios muestrales con 5000 muestras con reemplazo de tamaño 100. 

---

2) **Calcula el error estándar de la _distribución muestral_** asociada al estimador que calculaste en el punto anterior (10 pts.).

**Para Meade: **


```r
# Meade
set.seed(1)
computos %&gt;% 
  rep_sample_n(size = nrow(computos), replace = T, reps = 5000) %&gt;% 
  summarise(media_muestral = mean(vs_meade, na.rm = T)) %&gt;%
  summarise(error_estandar = sd(media_muestral, na.rm = T))
```

```
## # A tibble: 1 x 1
##   error_estandar
##            &lt;dbl&gt;
## 1          0.994
```

---

2) **Calcula el error estándar de la _distribución muestral_** asociada al estimador que calculaste en el punto anterior (10 pts.).

**Para AMLO: **


```r
# AMLO
set.seed(1)
computos %&gt;% 
  rep_sample_n(size = nrow(computos), replace = T, reps = 5000) %&gt;% 
  summarise(media_muestral = mean(vs_amlo, na.rm = T)) %&gt;%
  summarise(error_estandar = sd(media_muestral, na.rm = T))
```

```
## # A tibble: 1 x 1
##   error_estandar
##            &lt;dbl&gt;
## 1           1.68
```

---

3) Construye un intervalo de confianza con un nivel de confianza de 95% (15 pts.)

* Recordemos que el *valor Z* de un 95% de confianza es igual a **1.96**. 

**Para Anaya: **


```r
# Anaya
set.seed(1)
computos %&gt;% 
  rep_sample_n(size = nrow(computos), replace = T, reps = 1) %&gt;% 
  summarise(media_muestral = mean(vs_anaya, na.rm = T), 
            EE = sd(vs_anaya, na.rm = T)/sqrt(nrow(computos))) %&gt;% 
  summarise(limite_inf = media_muestral - 1.96*EE ,
            limite_sup = media_muestral + 1.96*EE, 
            media_muestral = media_muestral)
```

```
## # A tibble: 1 x 3
##   limite_inf limite_sup media_muestral
##        &lt;dbl&gt;      &lt;dbl&gt;          &lt;dbl&gt;
## 1       18.7       23.3           21.0
```

---

3) Construye un intervalo de confianza con un nivel de confianza de 95% (15 pts.)

**Para Meade: **


```r
# Meade
set.seed(1)
computos %&gt;% 
  rep_sample_n(size = nrow(computos), replace = T, reps = 1) %&gt;% 
  summarise(media_muestral = mean(vs_meade, na.rm = T), 
            EE = sd(vs_meade, na.rm = T)/sqrt(nrow(computos))) %&gt;% 
  summarise(limite_inf = media_muestral - 1.96*EE ,
            limite_sup = media_muestral + 1.96*EE, 
            media_muestral = media_muestral)
```

```
## # A tibble: 1 x 3
##   limite_inf limite_sup media_muestral
##        &lt;dbl&gt;      &lt;dbl&gt;          &lt;dbl&gt;
## 1       15.2       18.7           17.0
```

---

3) Construye un intervalo de confianza con un nivel de confianza de 95% (15 pts.)

**Para AMLO: **


```r
# AMLO
set.seed(1)
computos %&gt;% 
  rep_sample_n(size = nrow(computos), replace = T, reps = 1) %&gt;% 
  summarise(media_muestral = mean(vs_amlo, na.rm = T), 
            EE = sd(vs_amlo, na.rm = T)/sqrt(nrow(computos))) %&gt;% 
  summarise(limite_inf = media_muestral - 1.96*EE ,
            limite_sup = media_muestral + 1.96*EE, 
            media_muestral = media_muestral)
```

```
## # A tibble: 1 x 3
##   limite_inf limite_sup media_muestral
##        &lt;dbl&gt;      &lt;dbl&gt;          &lt;dbl&gt;
## 1       49.7       55.8           52.8
```

---

4) Supongamos que todo este análisis es para el equipo de campaña del candidato que elegiste (15 pts.). 

- **¿Crees que estarían satisfechos (en términos estadísticos) con los resultados que les entregas?**

- **¿Qué les sugerirías para mejorar tu próxima estimación?**

---

## Ejercicio 2 (20 pts.) {-}

Además de toda la magia que `ggplot2` ofrece para graficar, es un paquete que viene con varias bases de datos incluidas. Una de ellas es `midwest`, una base de datos con **28** variables sobre los **437** condados en el *Midwest* de Estados Unidos.

Para usar estos datos, solo debes escribir `midwest` en RStudio. 

1) Calcula el máximo de la variable `poptotal` usando los datos de *toda* la base (5 pts).


```r
max(midwest$poptotal)
```

```
## [1] 5105067
```

---

2) Usando lo visto en clase, determina **computacionalmente** si el máximo es un estimador insesgado (15 pts).


```r
midwest %&gt;% 
  rep_sample_n(size = 100, replace = F, reps = 1000) %&gt;% 
  summarise(maximo_muestral = max(poptotal)) %&gt;% 
  summarise(promedio_maximo_muestral = mean(maximo_muestral))
```

```
## # A tibble: 1 x 1
##   promedio_maximo_muestral
##                      &lt;dbl&gt;
## 1                 2142780.
```

Si el valor máximo de la `poptotal` es de 5´105,067, y el valor esperado es de 2´142,780, podemos pensar que no es un estimador insesgado, ya que su valor esperado (su promedio) está muy lejos del valor poblacional. 

---

## Ejercicio 3 (40 pts.) {-}

1) Simula la distribución de probabilidad de una variable aleatoria con las siguientes especificaciones (5 pts.):

- Se distribuye como una Normal, con `\(\mu=7\)` y `\(\sigma=2.5\)`;

- Debes usar 100 mil procesos aleatorios para generar los datos, para quedarte con un vector de las mismas dimensiones.

- Guarda las 100 mil observaciones en un vector llamado `valores`, que a su vez debes guardar en un `tibble`. Debes guardar el `tibble` en un objeto llamado `datos`.

- Usa `set.seed(89)` **antes** de simular los datos


```r
set.seed(89)
datos &lt;- tibble(valores = rnorm(n = 1e5, 
                                mean = 7, 
                                sd = 2.5))
```

---

2) Toma **1,000** muestras aleatorias de tamaño **500** de `datos`. Después, haz lo siguiente (15 pts.):

- Para cada una de las muestras, calcula la media.

- Calcula de forma *computacional* el error estándar de la distribución muestral utilizando las *1,000* estimaciones que recien calculaste.


```r
datos %&gt;% 
  rep_sample_n(size = 500, replace = F, reps = 1000) %&gt;% 
# - Para cada una de las muestras, calcula la media.  
  summarise(media_muestral = mean(valores)) %&gt;% 
# Calcula de forma *computacional* el EE de la distribución muestral
  summarise(error_estandar = sd(media_muestral))
```

```
## # A tibble: 1 x 1
##   error_estandar
##            &lt;dbl&gt;
## 1          0.110
```

---

3) Toma solo **una** muestra aleatoria de tamaño **500** de `datos`. Después, haz lo siguiente (20 pts.):

- Calcula la media muestral
- Calcula de forma *analítica* el error estándar de la distribución muestral asociada a tu estimador, usando el valor de la desviación estándar poblacional
- Calcula de forma *analítica* el error estándar de la distribución muestral, asumiendo que -como suele ocurrir en la realidad- **no conoces** el valor de la desviación estándar poblacional.


```r
datos %&gt;% 
  rep_sample_n(size = 500, replace = F, reps = 1) %&gt;% 
  summarise(media_muestral = mean(valores), 
            EEconDatosPoblacionales = 2.5/sqrt(500),   # Conociendo los parametros poblacionales
            EEAnalitico = sd(valores)/sqrt(500))    # Calculo analítico
```

```
## # A tibble: 1 x 4
##   replicate media_muestral EEconDatosPoblacionales EEAnalitico
##       &lt;int&gt;          &lt;dbl&gt;                   &lt;dbl&gt;       &lt;dbl&gt;
## 1         1           7.06                   0.112       0.111
```

---

## Ejercicio extra (40 pts.) {-}

Copia y ejecuta el siguiente código:


```r
foo &lt;- 
  tibble(valores = rnorm(n = 10000, mean = 14, sd = 3.5)) %&gt;%
  rep_sample_n(size = 500, replace = F, reps = 10000) %&gt;% 
  summarise(varianza_muestral = var(valores))
```

---

Después de hacerlo, deberías un `tibble` como este:


```r
foo &lt;- 
  tibble(valores = rnorm(n = 10000, mean = 14, sd = 3.5)) %&gt;%
  rep_sample_n(size = 500, replace = F, reps = 10000) %&gt;% 
  summarise(varianza_muestral = var(valores))

foo
```

```
## # A tibble: 10,000 x 2
##    replicate varianza_muestral
##        &lt;int&gt;             &lt;dbl&gt;
##  1         1              12.7
##  2         2              12.1
##  3         3              12.0
##  4         4              12.8
##  5         5              12.6
##  6         6              11.9
##  7         7              11.1
##  8         8              11.9
##  9         9              11.4
## 10        10              12.2
## # … with 9,990 more rows
```

---

Por favor, haz calcula y/o grafica todo lo que puedas a partir de la columna varianza muestral.

**¿Qué podemos calcular o graficar?**

* (1.) El valor de la varianza. 


```r
# Si la varianza es el cuadrado de la desviación estandar, y conocemos 
## el valor de la desv. est. poblacional (3.5), entonces 
varianza &lt;- 3.5*3.5
varianza
```

```
## [1] 12.25
```

La varianza poblacional es igual a **12.25**.

---

* (2.) Podemos graficar la distribución de la varianza muestral: 


```r
# Distribución de la varianza. 
foo %&gt;% 
  ggplot(aes(x = varianza_muestral)) + 
  geom_density() + 
  geom_vline(xintercept = varianza, color = "red", 
             linetype = 2)
```

&lt;img src="PrezSesion4_files/figure-html/unnamed-chunk-17-1.png" height="300" style="display: block; margin: auto;" /&gt;

---

* (3.) Podemos sacar el error estándar de la distribución muestral de la varianza. 


```r
foo %&gt;% 
  summarise(EEvarianza = sd(varianza_muestral))
```

```
## # A tibble: 1 x 1
##   EEvarianza
##        &lt;dbl&gt;
## 1      0.753
```

---

* (4.) Podemos sacar el error muestral, para cada muestra, dado que conocemos los parámetros poblacionales.


```r
foo %&gt;% 
  mutate(errorMuestral = varianza_muestral - varianza)
```

```
## # A tibble: 10,000 x 3
##    replicate varianza_muestral errorMuestral
##        &lt;int&gt;             &lt;dbl&gt;         &lt;dbl&gt;
##  1         1              12.7        0.402 
##  2         2              12.1       -0.162 
##  3         3              12.0       -0.202 
##  4         4              12.8        0.576 
##  5         5              12.6        0.364 
##  6         6              11.9       -0.318 
##  7         7              11.1       -1.15  
##  8         8              11.9       -0.391 
##  9         9              11.4       -0.843 
## 10        10              12.2       -0.0382
## # … with 9,990 more rows
```

---

* (5.) Podemos graficar el error muestral


```r
foo %&gt;% 
  mutate(errorMuestral = varianza_muestral - 3.5^2) %&gt;% 
  ggplot(aes(errorMuestral)) + 
  geom_density() + 
  geom_vline(xintercept = 0, color = "blue", 
             linetype = 2) + 
  geom_vline(xintercept = -0.1392231, color = "red", 
             linetype = 2)
```

&lt;img src="PrezSesion4_files/figure-html/unnamed-chunk-20-1.png" height="300" style="display: block; margin: auto;" /&gt;

---

...y le sacamos el valor esperado, para ver si es igual a cero...


```r
foo %&gt;% 
  mutate(errorMuestral = varianza_muestral - 3.5^2) %&gt;% 
  summarise(valorEsperadoerrorMuestral = mean(errorMuestral))
```

```
## # A tibble: 1 x 1
##   valorEsperadoerrorMuestral
##                        &lt;dbl&gt;
## 1                     -0.139
```

No es igual a cero, por lo tanto la varianza es un estimador sesgado. 

--

**¿o no?**
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
