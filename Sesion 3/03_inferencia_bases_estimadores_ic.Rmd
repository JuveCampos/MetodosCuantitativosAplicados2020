---
title: "Laboratorio 3 - Respuestas a Tarea 3"
author: "Juvenal Campos y Sebasti치n Garrido"
date: "3/23/2020"
output:
  prettydoc::html_pretty:
    theme: leonids
    highlight: github
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Librer칤as y opciones.

```{r message=FALSE, cache=FALSE, warning=FALSE}

# Librerias y opciones
library(pacman)
p_load(moderndive, # Para hacer el muestreo
       tidyverse)  # Para usar la %>% y los verbos dplyr

# Para mostrar m치s n칰meros decimales en las tibbles.
options(pillar.sigfig = 7)
```

# Ejercicio 1

En clase analizamos si la **media** y la **mediana** eran estimadores insesgados del promedio de una poblaci칩n **normal**.

En este ejercicio har치s lo mismo, pero para una distribuci칩n **beta**. En [esta](https://onlinelibrary.wiley.com/doi/pdf/10.1002/9781119197096.app03) (p. 906) y [esta otra ](http://varianceexplained.org/statistics/beta_distribution_and_baseball/)^[En esta segunda liga basta con que leas los primeros dos p치rrafos, pero todo el post vale la pena.] ligas puedes aprender m치s sobre esta distribuci칩n.

a. Usa el siguiente c칩digo para construir la distribuci칩n:

```{r, echo = T, eval = T}
set.seed(1)
datos <- tibble(valores = 
                  rbeta(n = 1e6, 
                        shape1 = 6, 
                        shape2 = 1))
```

b. Grafica la distribuci칩n. 쮼s sim칠trica? Si la respuesta es no, 쯤u칠 tipo de sesgo tiene?

```{r, echo = T, eval = T}
datos %>%
  ggplot(aes(valores)) +
  geom_density()

# Sesgo izquierdo
```

c. Calcula la media y mediana poblacional

```{r, echo = T, eval = T}
est_pob <-
  datos %>%
  summarise(media_pob = mean(valores),
            mediana_pob = median(valores))

est_pob
```

#### Escenario 1

  - Planta un `set.seed(1)` y toma **1,000** muestras sin remplazo, cada una de tama침o **5**.
  - Calcula la media y mediana de cada muestra. Guarda los c치lculos de las medias muestrales en una variable llamada `media_muestral` y los de las medianas en `mediana_muestral`.
  - Calcula el promedio de `media_muestral` y `mediana_muestral`. Guarda los resultados en `promedio_medias_muestrales` y `promedio_medianas_muestrales`.

```{r, echo = T, eval = T}
set.seed(1)
datos %>%
  rep_sample_n(size = 5, reps = 1000) %>%
  summarise(media_muestral = mean(valores),
            mediana_muestral = median(valores)) %>%
  summarise(promedio_media_muestral =
              mean(media_muestral),
            promedio_mediana_muestral =
              mean(mediana_muestral)) %>%
  gather(key = variable,
         value = valor)
```

Por favor responde:

i. 쮼l promedio de alguno de los estimadores es igual a su respectivo par치metro poblacional?

**(Respuesta v치lida para todas las dem치s preguntas similares).**

> Si trabajamos con poquitos decimales, pudiera llegar a parecer que si, pero la probabilidad de que la estimaci칩n sea igual al par치metro poblacional es igual a cero (ya que el resultado de la estimaci칩n tambi칠n es una variable aleatoria cont칤nua, y la probabilidad de que una variable aleatoria cont칤nua sea igual a un n칰mero exacto es siempre igual a cero).

ii. Si es as칤, 쯖u치l? Si no es as칤, 쯖u치l est치 m치s cerca y por cu치nto?


> Ninguna estimaci칩n es igual al par치metro poblacional de la media, sin embargo, en el c칩digo siguiente vamos a estimar la diferencia que hay entre la estimaci칩n y el par치metro poblacional.

**OJO**: antes de responder estas preguntas, aseg칰rate de haber corrido primero `set.seed(1)` y despu칠s el chunk con tus c치lculos. De lo contrario no podremos replicar tus datos 游땩.

```{r, echo = T, eval = T}
set.seed(1)
datos %>%
  rep_sample_n(size = 5, reps = 1000) %>%
  summarise(media_muestral = mean(valores),
            mediana_muestral = median(valores)) %>%
  summarise(promedio_media_muestral =
              mean(media_muestral),
            promedio_mediana_muestral =
              mean(mediana_muestral)) %>%
  gather(key = variable,
         value = valor) %>%
  mutate(dif_absoluta_media = 
           ifelse(variable == "promedio_media_muestral",
                  yes = abs(est_pob$media_pob - valor),
                  no = abs(est_pob$mediana_pob - valor)))

```

#### Escenario 2

Repite los pasos del Escenario 1, pero ahora aumenta el tama침o de cada muestra a **50**.
   
Por favor responde:

i. 쮼l promedio de alguno de los estimadores es igual a su respectivo par치metro poblacional?

> Si trabajamos con poquitos decimales, pudiera llegar a parecer que si, pero la probabilidad de que la estimaci칩n sea igual al par치metro poblacional es igual a cero (ya que el resultado de la estimaci칩n tambi칠n es una variable aleatoria cont칤nua, y la probabilidad de que una variable aleatoria cont칤nua sea igual a un n칰mero exacto es siempre igual a cero).

ii. Si es as칤, 쯖u치l? Si no es as칤, 쯖u치l est치 m치s cerca y por cu치nto?

> Ninguna estimaci칩n es igual al par치metro poblacional de la media, sin embargo, en el c칩digo siguiente vamos a estimar la diferencia que hay entre la estimaci칩n y el par치metro poblacional.

```{r, echo = T, eval = T}
set.seed(1)
datos %>%
  rep_sample_n(size = 50, reps = 1000) %>%
  summarise(media_muestral = mean(valores),
            mediana_muestral = median(valores)) %>%
  summarise(promedio_media_muestral = mean(media_muestral),
            promedio_mediana_muestral = mean(mediana_muestral)) %>%
  gather(key = variable,
         value = valor) %>%
  mutate(dif_absoluta_media = 
           ifelse(variable == "promedio_media_muestral", 
                  yes = abs(est_pob$media_pob - valor), 
                  no = abs(est_pob$mediana_pob - valor)))
```

#### Escenario 3

Repite los pasos del Escenario 1, pero ahora aumenta el tama침o de cada muestra a **100**.
   
Por favor responde:

i. 쮼l promedio de alguno de los estimadores es igual a su respectivo par치metro poblacional?

> Si trabajamos con poquitos decimales, pudiera llegar a parecer que si, pero la probabilidad de que la estimaci칩n sea igual al par치metro poblacional es igual a cero (ya que el resultado de la estimaci칩n tambi칠n es una variable aleatoria cont칤nua, y la probabilidad de que una variable aleatoria cont칤nua sea igual a un n칰mero exacto es siempre igual a cero).

ii. Si es as칤, 쯖u치l? Si no es as칤, 쯖u치l est치 m치s cerca y por cu치nto?

> Ninguna estimaci칩n es igual al par치metro poblacional de la media, sin embargo, en el c칩digo siguiente vamos a estimar la diferencia que hay entre la estimaci칩n y el par치metro poblacional.

```{r, echo = T, eval = T}
set.seed(1)
datos %>%
  rep_sample_n(size = 100, reps = 1000) %>%
  summarise(media_muestral = mean(valores),
            mediana_muestral = median(valores)) %>%
  summarise(promedio_media_muestral = mean(media_muestral),
            promedio_mediana_muestral = mean(mediana_muestral)) %>%
  gather(key = variable,
         value = valor) %>%
  mutate(dif_absoluta_media = 
           ifelse(variable == "promedio_media_muestral", 
                  yes = abs(est_pob$media_pob - valor), 
                  no = abs(est_pob$mediana_pob - valor)))
```


#### Escenario 4

Repite los pasos del Escenario 1, pero ahora cambia el **n칰mero de muestras** de **1,000** a **10,000**. El tama침o de cada una seguir치 siendo de **5**.
   
Por favor responde:

i. 쮼l promedio de alguno de los estimadores es igual a su respectivo par치metro poblacional?

> Si trabajamos con poquitos decimales, pudiera llegar a parecer que si, pero la probabilidad de que la estimaci칩n sea igual al par치metro poblacional es igual a cero (ya que el resultado de la estimaci칩n tambi칠n es una variable aleatoria cont칤nua, y la probabilidad de que una variable aleatoria cont칤nua sea igual a un n칰mero exacto es siempre igual a cero).

ii. Si es as칤, 쯖u치l? Si no es as칤, 쯖u치l est치 m치s cerca y por cu치nto?

> Ninguna estimaci칩n es igual al par치metro poblacional de la media, sin embargo, en el c칩digo siguiente vamos a estimar la diferencia que hay entre la estimaci칩n y el par치metro poblacional.

```{r, echo = T, eval = T}
set.seed(1)
datos %>%
  rep_sample_n(size = 5, reps = 10000) %>%
  summarise(media_muestral = mean(valores),
            mediana_muestral = median(valores)) %>%
  summarise(promedio_media_muestral = mean(media_muestral),
            promedio_mediana_muestral = mean(mediana_muestral)) %>%
  gather(key = variable,
         value = valor) %>%
  mutate(dif_absoluta_media = 
           ifelse(variable == "promedio_media_muestral", 
                  yes = abs(est_pob$media_pob - valor), 
                  no = abs(est_pob$mediana_pob - valor)))
```

#### Reflexiones generales

Por favor piensa y responde las siguientes preguntas:

- 쯈u칠 pasa con el estimador de la media y la mediana conforme aumenta el **tama침o de cada muestra**? (comparaci칩n de escenarios 2 y 3 vs. 1)

> La diferencia de la media estimada con respecto al par치metro poblacional **disminuye a medida de que el tama침o de cada muestra aumenta**, mientras que, en el caso de la mediana, este disminuye del escenario 1 al 2, pero ya no del 2 al 3.

- 쯈u칠 pasa con el estimador de la media y la mediana conforme aumenta el **n칰mero de muestras**? (comparaci칩n de escenarios 4 vs. 1)

> Igualmente, la diferencia de las estimaciones **disminuye cuando aumentamos de 1,000 a 10,000 muestras** (del escenario 1 al escenario 4). Esto debido a que aumenta la cantidad de informaci칩n disponible para obtener el valor esperado.

# Ejercicio 2

A continuaci칩n ver치s el c칩digo que utilic칠 en clase para ilustrar qu칠 significa el nivel de confianza de un intervalo de confianza. Por favor c칩pialo y ejec칰talo en el script de tu tarea:

```{r, echo = T, eval = T}
# Paso 1 - Generar los datos poblacionales
set.seed(33)
datos <-
  tibble(valores = rnorm(n = 1e6, mean = 0, sd = 1))

# Paso 2 - Definir el tama침o de cada muestra y el n칰mero de muestras
tama침o_muestra <- 1000
numero_muestras <- 100

# Paso 3 - Calcular el error est치ndar de la media muestral, asumiendo
# que el tama침o de la muestra es 1,000
error_est_con_datos_pob <- sd(datos$valores)/sqrt(tama침o_muestra)

# Paso 4 - Calcular la media de cada muestra y construye su respectivo
# intervalo de confianza usando el error est치ndar que calculamos
# en el paso 3
set.seed(4)
datos %>%
  rep_sample_n(size = tama침o_muestra,
               replace = T,
               reps = numero_muestras) %>%
  summarise(media_muestral = mean(valores),
            lim_sup = media_muestral + 1.96*error_est_con_datos_pob,
            lim_inf = media_muestral - 1.96*error_est_con_datos_pob) %>%  
  mutate(color_intervalos = ifelse(lim_sup < 0 | lim_inf > 0,
                                   yes = "salmon", 
                                   no = "steelblue")) %>%
  ggplot(aes(x = replicate, 
             y = media_muestral, 
             color = color_intervalos)) +
  geom_hline(yintercept = 0, 
             color = "grey40", 
             linetype = 2, 
             size = 0.5) +
  geom_point(size = 2) +
  geom_errorbar(aes(ymin = lim_inf, 
                    ymax = lim_sup), 
                width = 0.01,
                alpha = 0.82, 
                size = 1) +
  scale_color_manual(values = 
                       c("salmon", "steelblue")) +
  labs(x = "\nN칰mero de simulaci칩n") +
  theme_minimal() +
  theme(axis.title.x = 
          element_text(hjust = 1, face = "bold",
                       color = "grey30", size = 15),
        axis.title.y = element_blank(),
        axis.text = element_text(size = 15),
        legend.position = "none")
```

1. Por favor explica qu칠 es lo que estoy haciendo en cada paso. Para el paso 3 basta con que expliques hasta el rengl칩n en donde uso `scale_color_manual()`.

**Paso 1** Generar los datos poblacionales.

```{r, echo = T, eval = F}
# Paso 1 - Generar los datos poblacionales
set.seed(33) # Fijamos semilla para que todo sea reproducible

# Generamos el tibble poblacional, que consiste en una variable
## aleatoria que distribuye de manera normal con par치metros 0
## y desviaci칩n est치ndar de 1
datos <-
  tibble(valores = 
           rnorm(n = 1e6, mean = 0, sd = 1))
```

**Paso 2** Definir el tama침o de cada muestra y el n칰mero de muestras.

```{r, echo = T, eval = F}
# Paso 2 - Definir el tama침o de cada muestra y el n칰mero de muestras
tama침o_muestra <- 1000 # Observaciones por muestra aleatoria
numero_muestras <- 100 # Numero de muestras
```

**Paso 3** Calcular el error est치ndar de la media muestral, asumiendo que el tama침o de la muestra es 1,000.

```{r, echo = T, eval = F}
# Paso 3 - Calcular el error est치ndar de la media muestral, asumiendo
# que el tama침o de la muestra es 1,000

# Calculamos el error est치ndar de la muestra con la formula normal.
error_est_con_datos_pob <- sd(datos$valores)/sqrt(tama침o_muestra)

```

**Paso 4** Calcular la media de cada muestra y construye su respectivo intervalo de confianza usando el error est치ndar que calculamos en el paso 3.

```{r, echo = T, eval = F}
# Paso 4 - Calcular la media de cada muestra y construye su respectivo # intervalo de confianza usando el error est치ndar que calculamos
# en el paso 3

set.seed(4) # Fijamos semilla de reproducibilidad

# Generamos las muestras:
datos %>%
  rep_sample_n(size = tama침o_muestra,
               replace = T,
               reps = numero_muestras) %>%
# Calculamos la estimaci칩n muestral y los l칤mites del I.C.
  summarise(media_muestral = mean(valores),
            lim_sup = media_muestral + 1.96*error_est_con_datos_pob,
            lim_inf = media_muestral - 1.96*error_est_con_datos_pob) %>%  
# Obtenemos las observaciones que caen fuera del I.C., y
##  les asignamos un color caracter칤stico
  mutate(color_intervalos = ifelse(lim_sup < 0 | lim_inf > 0,
                                   "salmon", "steelblue")) %>%
# Generamos la gr치fica; declaramos los canales  
  ggplot(aes(x = replicate, y = media_muestral, color = color_intervalos)) +
# Generamos una l칤nea recta que pasa por el 0 - EL par치metro
##  poblacional  
  geom_hline(yintercept = 0, color = "grey40", linetype = 2, size = 0.5) +
# Generamos una gr치fica de puntos que marquen la media muestral  
  geom_point(size = 2) +
# Generamos un errorbar; una gr치fica que genera segmentos
## de recta finitos, que marquen cada uno de nuestros I.C.  
  geom_errorbar(aes(ymin = lim_inf, ymax = lim_sup), width = 0.01,
                alpha = 0.82, size = 1) +
 
```

**Paso 5.** A침adimos elementos est칠ticos a la gr치fica.

```{r, echo = T, eval = F}  
# Colores de las errorbars
  scale_color_manual(values = c("salmon", "steelblue")) +
# Etiquetas del eje x  
  labs(x = "\nN칰mero de simulaci칩n") +
# Tema m칤nimo (fondo blanco y sin vida)
  theme_minimal() +
# Personalizaci칩n del tema:  
  theme(axis.title.x = element_text(hjust = 1, face = "bold",
                                    color = "grey30", size = 15),
        axis.title.y = element_blank(),
        axis.text = element_text(size = 15),
        legend.position = "none")
```


2. Asume que el viejo Segasi no sabe nada de estad칤stica. Por favor expl칤cale de forma comprensible qu칠 **S칈** es y que **NO** es el nivel de confianza de un intervalo de confianza.

**Que no es un Intervalo de Confianza: **

> **NO ES** la probabilidad de que un par치metro poblacional se encuentre dentro de cierto rango.

**Que es un Intervalo de Confianza**.

> Son las veces que, repitiendo n veces (donde n tiende a infinito) un proceso de muestreo, los intervalos de confianza resultantes contienen al par치metro poblacional al menos un x % de veces, siendo x el nivel de confianza.

3. Por favor explica por qu칠 si en el c칩digo anterior usas `set.seed(4)` al comienzo del paso 3, hay m치s de cinco intervalos de confianza rojos. R se equivoc칩?

**A ver 游.**

```{r, echo = T, eval = T}  

# FIJAMOS LA SEMILLA QUE DICE SEGASI
set.seed(4)

# Paso 3 - Calcular el error est치ndar de la media muestral, asumiendo
# que el tama침o de la muestra es 1,000
error_est_con_datos_pob <- sd(datos$valores)/sqrt(tama침o_muestra)

# Paso 4 - Calcular la media de cada muestra y construye su respectivo
# intervalo de confianza usando el error est치ndar que calculamos
# en el paso 3
set.seed(4)
datos %>%
  rep_sample_n(size = tama침o_muestra,
               replace = T,
               reps = numero_muestras) %>%
  summarise(media_muestral = mean(valores),
            lim_sup = media_muestral + 1.96*error_est_con_datos_pob,
            lim_inf = media_muestral - 1.96*error_est_con_datos_pob) %>%  
  mutate(color_intervalos = ifelse(lim_sup < 0 | lim_inf > 0,
                                   "salmon", "steelblue")) %>%
  ggplot(aes(x = replicate, y = media_muestral, color = color_intervalos)) +
  geom_hline(yintercept = 0, color = "grey40", linetype = 2, size = 0.5) +
  geom_point(size = 2) +
  geom_errorbar(aes(ymin = lim_inf, ymax = lim_sup), width = 0.01,
                alpha = 0.82, size = 1) +
  scale_color_manual(values = c("salmon", "steelblue")) +
  labs(x = "\nN칰mero de simulaci칩n") +
  theme_minimal() +
  theme(axis.title.x = element_text(hjust = 1, face = "bold",
                                    color = "grey30", size = 15),
        axis.title.y = element_blank(),
        axis.text = element_text(size = 15),
        legend.position = "none")
```

> No, R no se equivoc칩. Lo que pasa es que, por probabilidad, es posible que de los primeros 100 Intervalos de Confianza simulados, haya m치s de 5 en los que no cae el par치metro poblacional. Sin embargo, si replicamos este modelo un n칰mero muy grande de veces, la poporci칩n de intervalos que acaparen el par치metro poblacional efectivamente va a tender al 95 %.

4. Partiendo del c칩digo que tienes arriba, ajusta el c칩digo para (i) aumentar el n칰mero de muestras a **10,000**; (ii) calcular la proporci칩n de intervalos de confianza generados con estas muestras que incluyen al par치metro poblacional. **NO TIENES QUE GRAFICAR LOS 100K INTERVALOS DE CONFIANZA**.

```{r, echo = T, eval = T}
# Paso 1 - Generar los datos poblacionales
set.seed(33)
datos <-
  tibble(valores = rnorm(n = 1e6, mean = 0, sd = 1))

# Paso 2 - Definir el tama침o de cada muestra y el n칰mero de muestras
tama침o_muestra <- 1000
numero_muestras <- 10000

# Paso 3 - Calcular el error est치ndar de la media muestral, asumiendo
# que el tama침o de la muestra es 1,000
error_est_con_datos_pob <- sd(datos$valores)/sqrt(tama침o_muestra)

# Paso 4 - Calcular la media de cada muestra y construye su respectivo
# intervalo de confianza usando el error est치ndar que calculamos
# en el paso 3
set.seed(4)
datos %>%
  rep_sample_n(size = tama침o_muestra,
               replace = T,
               reps = numero_muestras) %>%
  summarise(media_muestral = mean(valores),
            lim_sup = media_muestral + 1.96*error_est_con_datos_pob,
            lim_inf = media_muestral - 1.96*error_est_con_datos_pob) %>%  
  summarise(intervalo_incluye = 
              sum(ifelse(lim_sup < 0 | lim_inf > 0, 0, 1))) %>%
  mutate(prop_incluye = intervalo_incluye/numero_muestras)
```

> Como podemos ver ac치, ya ahora si la proporci칩n de intervalos se aproxima al 95 %.


# Ejercicio 3

En el paso 3 del ejercicio anterior us칠 la desviaci칩n est치ndar de la variable poblacional (misma que en el paso 1 definimos como `sd = 1`) para calcular el error est치ndar de la distribuci칩n muestral de la media.

En la vida real, es muy poco probable que conozcamos la desviaci칩n est치ndar de la variable poblacional, as칤 que en este ejercicio asumiremos que no la conocemos.

Por favor calcula el **error est치ndar de la distribuci칩n muestral de la media** usando la estimaci칩n de la desviaci칩n est치ndar de la variable poblacional con los datos de **100** muestras. Guardar치s el resultado de este c치lculo en una variable llamada `error_est_datos_muestra`.

**OJO:** Dado que debes estimar la desviaci칩n est치ndar de la variable poblacional con los datos de cada muestra por separado, al final del ejercicio deber치s tener un tibble con 100 renglones (uno por muestra) y tres columnas: `replicate`, `media_muestral` y  `error_est_datos_muestra`.

```{r, echo = T, eval = T}
# Paso 1 - Generar los datos poblacionales
set.seed(33)
datos <-
  tibble(valores = rnorm(n = 1e6, mean = 0, sd = 1))

# Paso 2 - Definir el tama침o de cada muestra y el n칰mero de muestras
tama침o_muestra <- 1000
numero_muestras <- 100

# Paso 3 - Calcular la media de cada muestra y el error est치ndar de la media muestral, estimando la desviaci칩n est치ndar de la variable poblacional.

set.seed(4)
datos %>%
  rep_sample_n(size = tama침o_muestra,
               replace = T,
               reps = numero_muestras) %>%
  summarise(media_muestral = mean(valores),
            error_est_datos_muestra = 
              sd(valores)/sqrt(tama침o_muestra))

```

1. 쯃os valores en la columna `error_est_datos_muestra` todos iguales? 쮼sto est치 bien o es se침al de que hay un problema?

> Los errores est치ndar de los datos de la muestra son todos distintos, porque es un error est치ndar por cada una de las estimaciones de la media de la muestra var칤a para cada muestra diferente.

2. 쯃os valores en la columna `error_est_datos_muestra` son exactamente iguales al valor que obtuvimos en el paso 3 del ejercicio anterior? 쮼sto est치 bien o es se침al de que hay un problema?

> No son iguales (aunque si muy similares), ya que el error est치ndar del ejercicio 3 se calcul칩 con el valor de la desviaci칩n est치ndar de todos los datos de la poblaci칩n, mientras que el error est치ndar calculado en este ejercicio se realiz칩 con la estimaci칩n muestral de esta desviaci칩n est치ndar.

# Ejercicio 4

Repasemos la diferencia entre error **muestral** y error **est치ndar**. Para ello usaremos los datos de una distribuci칩n **gamma**. En [esta](https://onlinelibrary.wiley.com/doi/pdf/10.1002/9781119197096.app03) (p. 910) y [esta liga](http://wiki.stat.ucla.edu/socr/index.php/AP_Statistics_Curriculum_2007_Gamma) encontrar치s m치s detalles sobre esta distribuci칩n.

a. Usa el siguiente c칩digo para construir la distribuci칩n:

```{r, echo = T, eval = T}
library(tidyverse)
library(moderndive)
datos <- tibble(valores = rgamma(n = 1e5, shape = 2, scale = 1))
```

b. Toma **100** muestras aleatorias de tama침o **120**, calcula la media de cada muestra y el o los error(es) muestral(es)

```{r, echo = T, eval = T}

datos %>%
  rep_sample_n(size = 120, reps = 100) %>%
# Calculamos la media de cada muestra
  summarise(media_muestral = mean(valores)) %>%
# Calculamos el error muestral de cada muestra con el Par. Pob.
  mutate(error_muestral = media_muestral - mean(datos$valores))

```

c. Toma **100** muestras aleatorias de tama침o **120**, calcula la media de cada muestra y el o los error(es) est치ndar.

```{r, echo = T, eval = T}
bd <- datos %>%
  rep_sample_n(size = 120, reps = 1000) %>%
  summarise(media_muestral = mean(valores),
            error_estandar_media_muestral = 
              sd(valores)/sqrt(120)) 
# %>%
#   summarise(error_estandar = sd(media_muestral))

ggplot(data = bd, aes(error_estandar_media_muestral)) +
  geom_density()

```

# Ejercicio 5

Basta de simulaciones. Bueno, casi. En este ejercicio tendr치s que seguir el caminito lleno de incertidumbre de toda persona que trata de entender las caracter칤sticas de una poblaci칩n a partir de una muestra.

a. Asume que **67%** de la poblaci칩n de M칠xico est치 a favor del paro nacional del 9 de marzo "Un d칤a sin mujeres" ([liga](https://elfinanciero.com.mx/nacional/57-de-las-mujeres-piensan-sumarse-al-paro-nacional)) y el **33%** restante est치 en contra. Construye una poblaci칩n hipot칠tica de **1 mill칩n** de personas con estas proporciones. Puedes representar a los que est치n a favor del paro con un **1** y a los que est치n en contra con un **0**.

b. Olvida que sabes las proporciones poblacionales.

c. Planta un `set.seed(1)` y toma **una** sola muestra de tama침o **500**.

d. Usando los datos de tu muestra, estima la proporci칩n de personas que est치 a favor del paro.

e. Usando los datos de tu muestra, construye un intervalo de confianza de 99%.

f. Reporta los resultados mostrando la/el pro que eres.  

**Muestra de tama침o 500**

```{r, echo = T, eval = T}
poblacion <- tibble(preferencia = c(rep(1, 670000), rep(0, 330000)))

tama침o_muestra <-  500

# Mi propuesta :3
poblacion %>%
  rep_sample_n(size = tama침o_muestra, reps = 1) %>%
  summarise(proporcion_muestral = mean(preferencia),
            EE = sd(preferencia)/sqrt(tama침o_muestra)) %>%
  mutate(lim_inf = proporcion_muestral - 2.58*EE,
         lim_sup = proporcion_muestral + 2.58*EE,
         mult = 2.58*EE)

```

**Reportar como pro: **

> Seg칰n una encuesta realizada por los alumnos de CPRI del CIDE a inicios de marzo del 2020, un 68.3 % (mas/menos 3.7%) de la poblaci칩n mexicana se encuentra a favor del paro del 9 de marzo. El intervalo de confianza abarca desde 66.46 a un 73.93 %, con un nivel de confianza del 99 %.

g. Repite los pasos c), d) y e) usando una muestra de tama침o **100**, y posteriormente una muestra de tama침o **1,000**. 쯈u칠 efecto tiene el tama침o de la muestra en el tama침o del intervalo de confianza?

**Muestra de tama침o 100**

```{r, echo = T, eval = T}
poblacion <- tibble(preferencia = c(rep(1, 670000), rep(0, 330000)))

tama침o_muestra <-  100

# Mi propuesta :3
poblacion %>%
  rep_sample_n(size = tama침o_muestra, reps = 1) %>%
  summarise(proporcion_muestral = mean(preferencia),
            EE = sd(preferencia)/sqrt(tama침o_muestra)) %>%
  mutate(lim_inf = proporcion_muestral - 2.58*EE,
         lim_sup = proporcion_muestral + 2.58*EE)

```

**Muestra de tama침o 1,000**

```{r, echo = T, eval = T}
poblacion <- tibble(preferencia = c(rep(1, 670000), rep(0, 330000)))

tama침o_muestra <-  1000

# Mi propuesta :3
poblacion %>%
  rep_sample_n(size = tama침o_muestra, reps = 1) %>%
  summarise(proporcion_muestral = mean(preferencia),
            EE = sd(preferencia)/sqrt(tama침o_muestra)) %>%
  mutate(lim_inf = proporcion_muestral - 2.58*EE,
         lim_sup = proporcion_muestral + 2.58*EE)

```

**R:** A medida en que el tama침o de la muestra va creciendo, el intervalo de confianza se va volviendo m치s angosto.